# Code generated by jtd-codegen for Python v0.3.1

import re
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, Optional, Type, Union, get_args, get_origin


@dataclass
class PytamaroTypes:
    value: "Any"

    @classmethod
    def from_json_data(cls, data: Any) -> "PytamaroTypes":
        return cls(_from_json_data(Any, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)


@dataclass
class Color:
    alpha: "float"
    blue: "int"
    green: "int"
    red: "int"

    @classmethod
    def from_json_data(cls, data: Any) -> "Color":
        return cls(
            _from_json_data(float, data.get("alpha")),
            _from_json_data(int, data.get("blue")),
            _from_json_data(int, data.get("green")),
            _from_json_data(int, data.get("red")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["alpha"] = _to_json_data(self.alpha)
        data["blue"] = _to_json_data(self.blue)
        data["green"] = _to_json_data(self.green)
        data["red"] = _to_json_data(self.red)
        return data


@dataclass
class Graphic:
    id: "str"

    @classmethod
    def from_json_data(cls, data: Any) -> "Graphic":
        variants: Dict[str, Type[Graphic]] = {
            "above": GraphicAbove,
            "beside": GraphicBeside,
            "circularSector": GraphicCircularSector,
            "compose": GraphicCompose,
            "ellipse": GraphicEllipse,
            "empty": GraphicEmpty,
            "overlay": GraphicOverlay,
            "pin": GraphicPin,
            "rectangle": GraphicRectangle,
            "rotate": GraphicRotate,
            "text": GraphicText,
            "triangle": GraphicTriangle,
        }

        return variants[data["id"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass


@dataclass
class GraphicAbove(Graphic):
    bottom_graphic: "Graphic"
    top_graphic: "Graphic"

    @classmethod
    def from_json_data(cls, data: Any) -> "GraphicAbove":
        return cls(
            "above",
            _from_json_data(Graphic, data.get("bottom_graphic")),
            _from_json_data(Graphic, data.get("top_graphic")),
        )

    def to_json_data(self) -> Any:
        data = {"id": "above"}
        data["bottom_graphic"] = _to_json_data(self.bottom_graphic)
        data["top_graphic"] = _to_json_data(self.top_graphic)
        return data


@dataclass
class GraphicBeside(Graphic):
    left_graphic: "Graphic"
    right_graphic: "Graphic"

    @classmethod
    def from_json_data(cls, data: Any) -> "GraphicBeside":
        return cls(
            "beside",
            _from_json_data(Graphic, data.get("left_graphic")),
            _from_json_data(Graphic, data.get("right_graphic")),
        )

    def to_json_data(self) -> Any:
        data = {"id": "beside"}
        data["left_graphic"] = _to_json_data(self.left_graphic)
        data["right_graphic"] = _to_json_data(self.right_graphic)
        return data


@dataclass
class GraphicCircularSector(Graphic):
    angle: "float"
    color: "Color"
    radius: "float"

    @classmethod
    def from_json_data(cls, data: Any) -> "GraphicCircularSector":
        return cls(
            "circularSector",
            _from_json_data(float, data.get("angle")),
            _from_json_data(Color, data.get("color")),
            _from_json_data(float, data.get("radius")),
        )

    def to_json_data(self) -> Any:
        data = {"id": "circularSector"}
        data["angle"] = _to_json_data(self.angle)
        data["color"] = _to_json_data(self.color)
        data["radius"] = _to_json_data(self.radius)
        return data


@dataclass
class GraphicCompose(Graphic):
    background: "Graphic"
    foreground: "Graphic"

    @classmethod
    def from_json_data(cls, data: Any) -> "GraphicCompose":
        return cls(
            "compose",
            _from_json_data(Graphic, data.get("background")),
            _from_json_data(Graphic, data.get("foreground")),
        )

    def to_json_data(self) -> Any:
        data = {"id": "compose"}
        data["background"] = _to_json_data(self.background)
        data["foreground"] = _to_json_data(self.foreground)
        return data


@dataclass
class GraphicEllipse(Graphic):
    color: "Color"
    height: "float"
    width: "float"

    @classmethod
    def from_json_data(cls, data: Any) -> "GraphicEllipse":
        return cls(
            "ellipse",
            _from_json_data(Color, data.get("color")),
            _from_json_data(float, data.get("height")),
            _from_json_data(float, data.get("width")),
        )

    def to_json_data(self) -> Any:
        data = {"id": "ellipse"}
        data["color"] = _to_json_data(self.color)
        data["height"] = _to_json_data(self.height)
        data["width"] = _to_json_data(self.width)
        return data


@dataclass
class GraphicEmpty(Graphic):

    @classmethod
    def from_json_data(cls, data: Any) -> "GraphicEmpty":
        return cls(
            "empty",
        )

    def to_json_data(self) -> Any:
        data = {"id": "empty"}
        return data


@dataclass
class GraphicOverlay(Graphic):
    back_graphic: "Graphic"
    front_graphic: "Graphic"

    @classmethod
    def from_json_data(cls, data: Any) -> "GraphicOverlay":
        return cls(
            "overlay",
            _from_json_data(Graphic, data.get("back_graphic")),
            _from_json_data(Graphic, data.get("front_graphic")),
        )

    def to_json_data(self) -> Any:
        data = {"id": "overlay"}
        data["back_graphic"] = _to_json_data(self.back_graphic)
        data["front_graphic"] = _to_json_data(self.front_graphic)
        return data


@dataclass
class GraphicPin(Graphic):
    graphic: "Graphic"
    pinning_point: "Point"

    @classmethod
    def from_json_data(cls, data: Any) -> "GraphicPin":
        return cls(
            "pin",
            _from_json_data(Graphic, data.get("graphic")),
            _from_json_data(Point, data.get("pinning_point")),
        )

    def to_json_data(self) -> Any:
        data = {"id": "pin"}
        data["graphic"] = _to_json_data(self.graphic)
        data["pinning_point"] = _to_json_data(self.pinning_point)
        return data


@dataclass
class GraphicRectangle(Graphic):
    color: "Color"
    height: "float"
    width: "float"

    @classmethod
    def from_json_data(cls, data: Any) -> "GraphicRectangle":
        return cls(
            "rectangle",
            _from_json_data(Color, data.get("color")),
            _from_json_data(float, data.get("height")),
            _from_json_data(float, data.get("width")),
        )

    def to_json_data(self) -> Any:
        data = {"id": "rectangle"}
        data["color"] = _to_json_data(self.color)
        data["height"] = _to_json_data(self.height)
        data["width"] = _to_json_data(self.width)
        return data


@dataclass
class GraphicRotate(Graphic):
    angle: "float"
    graphic: "Graphic"

    @classmethod
    def from_json_data(cls, data: Any) -> "GraphicRotate":
        return cls(
            "rotate",
            _from_json_data(float, data.get("angle")),
            _from_json_data(Graphic, data.get("graphic")),
        )

    def to_json_data(self) -> Any:
        data = {"id": "rotate"}
        data["angle"] = _to_json_data(self.angle)
        data["graphic"] = _to_json_data(self.graphic)
        return data


@dataclass
class GraphicText(Graphic):
    color: "Color"
    font_name: "str"
    text: "str"
    text_size: "float"

    @classmethod
    def from_json_data(cls, data: Any) -> "GraphicText":
        return cls(
            "text",
            _from_json_data(Color, data.get("color")),
            _from_json_data(str, data.get("font_name")),
            _from_json_data(str, data.get("text")),
            _from_json_data(float, data.get("text_size")),
        )

    def to_json_data(self) -> Any:
        data = {"id": "text"}
        data["color"] = _to_json_data(self.color)
        data["font_name"] = _to_json_data(self.font_name)
        data["text"] = _to_json_data(self.text)
        data["text_size"] = _to_json_data(self.text_size)
        return data


@dataclass
class GraphicTriangle(Graphic):
    angle: "float"
    color: "Color"
    side1: "float"
    side2: "float"

    @classmethod
    def from_json_data(cls, data: Any) -> "GraphicTriangle":
        return cls(
            "triangle",
            _from_json_data(float, data.get("angle")),
            _from_json_data(Color, data.get("color")),
            _from_json_data(float, data.get("side1")),
            _from_json_data(float, data.get("side2")),
        )

    def to_json_data(self) -> Any:
        data = {"id": "triangle"}
        data["angle"] = _to_json_data(self.angle)
        data["color"] = _to_json_data(self.color)
        data["side1"] = _to_json_data(self.side1)
        data["side2"] = _to_json_data(self.side2)
        return data


@dataclass
class Point:
    x: "float"
    y: "float"

    @classmethod
    def from_json_data(cls, data: Any) -> "Point":
        return cls(
            _from_json_data(float, data.get("x")),
            _from_json_data(float, data.get("y")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["x"] = _to_json_data(self.x)
        data["y"] = _to_json_data(self.y)
        return data


def _from_json_data(cls: Any, data: Any) -> Any:
    if data is None or cls in [bool, int, float, str, object] or cls is Any:
        return data
    if cls is datetime:
        return _parse_rfc3339(data)
    if get_origin(cls) is Union:
        return _from_json_data(get_args(cls)[0], data)
    if get_origin(cls) is list:
        return [_from_json_data(get_args(cls)[0], d) for d in data]
    if get_origin(cls) is dict:
        return {k: _from_json_data(get_args(cls)[1], v) for k, v in data.items()}
    return cls.from_json_data(data)


def _to_json_data(data: Any) -> Any:
    if data is None or type(data) in [bool, int, float, str, object]:
        return data
    if type(data) is datetime:
        return data.isoformat()
    if type(data) is list:
        return [_to_json_data(d) for d in data]
    if type(data) is dict:
        return {k: _to_json_data(v) for k, v in data.items()}
    return data.to_json_data()


def _parse_rfc3339(s: str) -> datetime:
    datetime_re = r"^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(\.\d+)?([zZ]|((\+|-)(\d{2}):(\d{2})))$"
    match = re.match(datetime_re, s)
    if not match:
        raise ValueError("Invalid RFC3339 date/time", s)

    (year, month, day, hour, minute, second, frac_seconds, offset, *tz) = match.groups()

    frac_seconds_parsed = None
    if frac_seconds:
        frac_seconds_parsed = int(float(frac_seconds) * 1_000_000)
    else:
        frac_seconds_parsed = 0

    tzinfo = None
    if offset == "Z":
        tzinfo = timezone.utc
    else:
        hours = int(tz[2])
        minutes = int(tz[3])
        sign = 1 if tz[1] == "+" else -1

        if minutes not in range(60):
            raise ValueError("minute offset must be in 0..59")

        tzinfo = timezone(timedelta(minutes=sign * (60 * hours + minutes)))

    second_parsed = int(second)
    if second_parsed == 60:
        second_parsed = 59

    return datetime(
        int(year),
        int(month),
        int(day),
        int(hour),
        int(minute),
        second_parsed,
        frac_seconds_parsed,
        tzinfo,
    )
